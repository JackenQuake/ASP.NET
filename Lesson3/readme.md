### Tasks description for Lesson 3:

#### Комментарии:

Задание к уроку 3 выполнено.
Задания выполнены согласно методичке! (на сайте и в методичке задания немного расходятся - в методичке задания шире).

Создание баз данных я перенес в репозиторий, чтобы вся работа с базами данных была в одном месте - чтобы, например, в разных файлах не дублировался ConnectionString (что потом чревато ошибками, если его понадобится менять и он станет разным в разных файлах). Для этого в репозиториях появился метод CreateDatabase, который, кроме того, позволяет и создать в базах тестовые записи - этим управляет параметр, true - создает записи, false - база будет пустой. Таким образом, в Startup.cs достаточно просто вызвать CreateDatabase для всех пяти репозиториев. По-моему, так логичнее с точки зрения структуры проекта.

Кроме того, у меня возник вопрос про using: как я понял, он отвечает за оперативное уничтожение объекта сразу, когда он стал не нужен, чтобы сразу освободить ресурсы и не ждать, когда там до объекта доберется сборщик мусора. Но с другой стороны, я не хотел создавать на каждое простейшее действие свой объект connection, поскольку, по-моему, установление связи с БД может быть длительной операцией, и на каждый запрос это лучше делать один раз. Поэтому предложена следующая архитектура: в репозитории имеется функция OpenConnection, которая возвращает соединение, и остальные функции принимают connection в качестве параметра. Но, если запрос требует только одной операции, то имеются сокращенные варианты, которые создают connection, выполняют операцию, и за счет using'а connection сразу будет уничтожен.
Это что-то вроде синтаксического сахара.
А если запрос требует нескольких операций - тогда уже вызывающему методу предлагается самостоятельно делать OpenConnection и отвечать за срок его жизни в пределах запроса. Надеюсь, я правильно понял, как работает using и правильно все организовал; может быть, есть лучшие и более правильные способы это делать, но я их не придумал.

Я реализовал логирование в контроллерах, и оно работает. Но я столкнулся с проблемой при использовании его из тестов: мне нужно передать в конструкторы объект-лог, и у меня его нет. А попытки вызвать GetCurrentClassLogger в конструкторе приводят к переполнению стека - полагаю, потому, что этот вызов пытается заново создать экземпляр объекта, заново вызывает конструктор и в итоге зацикливается.
В общем, закончилось тем, что я просто передаю null и не провожу логирование, если логгера нет.